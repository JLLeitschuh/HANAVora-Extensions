package org.apache.spark.sql.catalyst.plans.logical

import java.util.Locale

import org.apache.spark.sql.catalyst.analysis._
import org.apache.spark.sql.catalyst.expressions._
import org.apache.spark.sql.types.DataType

/**
  * Defines the hierarchy specification.
  */
sealed abstract class HierarchySpec extends UnaryNode {

  /**
    * The start where clause.
    */
  def startWhere: Option[Expression]

  /**
    * The child.
    */
  def source: LogicalPlan

  /**
    * The order by clause.
    */
  def orderBy: Seq[SortOrder]

  override def output: Seq[Attribute] = child.output

  override def child: LogicalPlan = source

  /**
    * Calculate an ad-hoc unique identifier of a hierarchy spec based on its defining clauses.
    */
  // TODO (YH) This is very limited because it takes literal
  // representation of the spec determine semantic equality
  // of hierarchies, a good approach should rely on semantic equality
  // of source tables (#105063), if we decide not to do this then we
  // should turn off the check of having different hierarchy node columns
  // used in the same UDF.
  def identifier: String = "OB" + orderBy.mkString(".") + "SW" + startWhere.mkString(".")

  /**
    * Attributes to prune from the analysis.
    *
    * @return The attributes to be pruned.
    */
  def prunedAttributes: AttributeSet

  /**
    * Determine the set of candidate attributes needed for the resolution.
    *
    * @return Set of candidate attributes.
    */
  def candidateAttributesForResolution: Seq[Attribute]

  /**
    * Gets the path data type.
    */
  def pathDataType: DataType

  private[sql] def resolveSpec(nameParts: Seq[String],
                               resolver: Resolver): Option[NamedExpression] = {
    resolve(nameParts, candidateAttributesForResolution, resolver)
  }
}

/**
  * Defines adjacency list hierarchy specification.
  *
  * @param childAlias The child alias.
  * @param parenthoodExp The parenthood expression.
  * @param startWhere Start where clause.
  * @param orderBy Order by clause.
  */
case class AdjacencyListHierarchySpec(source:LogicalPlan,
                                      childAlias: String,
                                      parenthoodExp: Expression,
                                      startWhere: Option[Expression],
                                      orderBy: Seq[SortOrder]) extends HierarchySpec {

  /**
    * @inheritdoc
    */
  override def identifier: String =
    parenthoodExp.toString().concat(super.identifier)
    .toLowerCase(Locale.ENGLISH)
    .replaceAll("#\\d+", "")
    .replaceAll("[^a-z0-9]+", "_")

  /**
    * @inheritdoc
    */
  override lazy val resolved: Boolean = parenthoodExp.resolved &&
    expressions.forall(_.resolved) && childrenResolved

  /**
   * When checking missing input attributes, ignore the node attribute
   * (which is generated by this plan) and any attribute in the parenthood
   * expression.
   *
   * XXX: Ignoring the parenthood expression is a hack to avoid more complex
   *      handling of expression IDs for the child relation and its "parent alias".
   */
  override def prunedAttributes: AttributeSet =
    AttributeSet(parenthoodExp.collect { case a: Attribute => a })

  /**
    * Candidate attributes for resolution in parenthood expression:
    *   - Every attribute in the child relation.
    *   - Every attribute in the child alias with the child alias added as qualifier.
    * For more info, check the JOIN PRIOR syntax.
    */
  override def candidateAttributesForResolution: Seq[Attribute] =
    source.output ++ source.output.map {
      case attr => Alias(attr, attr.name)(qualifiers = childAlias :: Nil).toAttribute
    }

  override def pathDataType: DataType = parenthoodExp.asInstanceOf[BinaryExpression].left.dataType

  override def missingInput: AttributeSet = references -- inputSet -- prunedAttributes
}

/**
  * Defines level-based hierarchy specification.
  *
  * @param levels The levels.
  * @param startWhere Start where clause.
  * @param orderBy Order by clause.
  */
case class LevelBasedHierarchySpec(source: LogicalPlan,
                                   levels: Seq[Expression],
                                   startWhere: Option[Expression],
                                   orderBy: Seq[SortOrder],
                                   matcher: LevelMatcher) extends HierarchySpec {

  /**
    * @inheritdoc
    */
  override lazy val resolved: Boolean = levels.forall(_.resolved) &&
    expressions.forall(_.resolved) && childrenResolved

  /**
    * @inheritdoc
    */
  override def identifier: String =
    levels.mkString(".").concat(super.identifier)
      .toLowerCase(Locale.ENGLISH)
      .replaceAll("#\\d+", "")
      .replaceAll("[^a-z0-9]+", "_")


  /**
    * @inheritdoc
    */
  override def prunedAttributes: AttributeSet = AttributeSet(levels)

  /**
    * @inheritdoc
    */
  override def candidateAttributesForResolution: Seq[Attribute] = source.output

  override def pathDataType: DataType = levels.head.dataType

  override def missingInput: AttributeSet = references -- inputSet -- prunedAttributes

  override def expressions: Seq[Expression] = levels ++ super.expressions
}
